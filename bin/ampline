#!/usr/bin/env node

/*
This script takes a wierd strategy.

- we want colors from scripts, so we would normally want to use a psuedo
terminal to trick the exec'd process into outputting colors. this is not possible
because node does not support pty. the solution is to specify a git config in
front of every git command.
- we cant child_process.spawn, because then the colors go away. if we specify
the stdio array, and pass in process.stdout, the colors stay. sadly we cannot
access/manipulate the data written there, b/c passing in anything else will cause
the child to stop thinking it is writing to a tty. also node gives you errors
for passing in the wrong kind of stream, sometimes.

- we want to export shell variables into the parents scope. this is not possible
b/c of how bash works. the solution to this, is to have this script output a bash
script. this is why you see "echo" and "export" as functions.

TODO: here is how this should work

You make aliases for your normal commands that instead call this. so...

  ampline 'filenamepattern' command_name
  ampline '.*$' git status -s

turns into

  alias gs="ampline '.*$'' git status -s"

now, if you wanted to add similar functionality to, say, ls -1:

alias ls="ampline '*' ls -1"


if ampline does not see a capture group as the first argument, it will simply
try to substitute any numbers (e.g. 1) or number ranges (e.g 1-9), with the
values of "$e1" or "$e1, $e2 ... $e9" respectively.

alias cat="ampline cat"

ampline will always try to substitute numbers for values in the variables.


ampline psuedo-code

  - if see numbers as arguments, substitute with the values of env variables
  - if see no pattern in arguments, execute the command
  - if see a pattern in arguments, generate a bash script that
    - prints original output of the command, with colors
    - sets the environment variables to the match on each line of output

this means that in order to use ampline, after you've `npm -g install`ed it,
add this to your ~/.bashrc or ~/.profile:

    ampline() {
      ampline-gen $TODO:all-args > /tmp/ampline-gen.sh
      source /tmp/ampline-gen.sh # set the environment variables
      "rm" /tmp/ampline-gen.sh   #
    }


// TODO: have ampline use its own set of env variables stored in some file.
// if the user wants access to the $e1 functionality, have them make an alias
// for ampline that is like this:
//     alias ampline='\ampline $TODO:all-args; source ~/.ampline-vars'
//
// or maybe just suggest they run
//           theircommand `ampline 1 3 5`
//  hmmmm i like this last option.
// might shorthand the project to "amp"
//
// consider calling the accompanying fuzzy search tool something similar
//   and it is really just invoked:
//
//    alias fuzzy="ampline '*' fuzzy"
//
//    > fuzzy abc
//    $e1 file1
//    $e2 file2
//    ...
//
// maybe remove the $e1 and just make it "1", since we will probably use our own
// set of variables b/c shell variables dont work well for parents.
//
*/

var util = require('util')
var exec = require('child_process').exec
var colors = require('colors')
var identity = function(i) { return i }
var trim = function(s) { return s.trim(); }

function echo(s) {
    if (typeof s === 'string') {
        s = s.replace(/\033/g, '\\033')
    }
    var stmt = "echo -e '" + s + "'"
    if (~process.argv.indexOf('print0')) process.stdout.write(stmt + '\0')
    else console.log(stmt)
}

// sadly export is a reserved word
function exportvar(a, b) {

    console.log("export %s='%s'", a, b);
};

var child = exec('git -c color.status=always status -s', onExec)
function onExec(err, stdout, stderr) {
  if (err) {
    console.error(err)
    process.exit(1)
  }

  var lines = stdout.split('\n').filter(identity);
  if (!lines.length) {
    process.exit(0)
  }

  var shellvars =
  lines.map(function(raw, i) {
    // keep things aligned even if there are many. will misalign after 100 lines
    i += ''
    if (lines.length > 9) && i.length === 1) i += ' '

    echo('$e' + i + ' ' + raw)

    l = raw.trim()

    // R  b_signup2.mote -> b_signup_billing.mote
    if ('R' === l[0]) {
      // add a bash function to the shell that returns this string
      return l.substring(l.lastIndexOf(' ') + 1)
    }
    // M filepath.ext
    // ?? newfile.ext
    return l.substring(l.indexOf(' ') + 1)
  })

  shellvars.forEach(function(v, i) {
    exportvar('e'+i, v.trim());
  })
}
