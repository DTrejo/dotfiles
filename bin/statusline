#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'open3'

DEBUG = false

# Validation helpers - raise on invalid input
def validate_path!(path)
  raise ArgumentError, "Invalid path: #{path.inspect}" unless path.match?(%r{\A[\w/.~-]+\z})

  path
end

def validate_repo_name!(name)
  raise ArgumentError, "Invalid repo name: #{name.inspect}" unless name.match?(/\A[\w.-]+\/[\w.-]+\z/)

  name
end

def validate_positive_integer!(val)
  raise ArgumentError, "Invalid integer: #{val.inspect}" unless val.is_a?(Integer) && val.positive?

  val
end

# Read JSON input from stdin
input = JSON.parse($stdin.read)

# Debug: print full JSON to stdout
if DEBUG
  puts "input = #{JSON.generate(input)}"
  _example_json = {
    "session_id": 'abc',
    "transcript_path": '/Users/user/.claude/projects/some.jsonl',
    "cwd": '/Users/user/dev/dotfiles',
    "model": {
      "id": 'us.anthropic.claude-sonnet-4-5-20250929-v1:0',
      "display_name": 'Sonnet 4.5'
    },
    "workspace": {
      "current_dir": '/Users/user/dev/dotfiles',
      "project_dir": '/Users/user/dev/dotfiles'
    },
    "version": '2.0.64',
    "output_style": {
      "name": 'default'
    },
    "cost": {
      "total_cost_usd": 0.2780467,
      "total_duration_ms": 492_396,
      "total_api_duration_ms": 168_356,
      "total_lines_added": 22,
      "total_lines_removed": 3
    },
    "exceeds_200k_tokens": false
  }
  puts "\n---\n"
end

# Extract data
model_name = input.dig('model', 'display_name')
current_dir = input.dig('workspace', 'current_dir')
cost = input.dig('cost', 'total_cost_usd')
# context_input = input.dig('context_window', 'total_input_tokens')
# context_output = input.dig('context_window', 'total_output_tokens')
# context_size = input.dig('context_window', 'context_window_size')

# Parse model name (handles various formats)
# e.g., "us.anthropic.claude-sonnet-4-5-20250929-v1:0" -> "sonnet 4.5"
# e.g., "Sonnet 4.5" -> "sonnet 4.5"
if model_name =~ /claude-(\w+)-(\d+)-(\d+)/
  # Extract from full model ID format
  family = Regexp.last_match(1)  # sonnet, opus, haiku
  major = Regexp.last_match(2)   # 4
  minor = Regexp.last_match(3)   # 5
  model_display = "#{family} #{major}.#{minor}"
else
  # Already in friendly format, just lowercase it
  model_display = model_name.downcase
end

# Convert to relative path from home (like %~ in zsh)
relative_dir = current_dir.sub(/^#{ENV['HOME']}/, '~')

# Get git branch
git_branch = ''
validated_dir = validate_path!(current_dir)
_, status = Open3.capture2('git', '-C', validated_dir, 'rev-parse', '--git-dir')
if status.success?
  git_branch, = Open3.capture2('git', '-C', validated_dir, '--no-optional-locks', 'branch', '--show-current')
  git_branch = git_branch.strip
end

# Get PR state using gh cli
def get_pr_state
  pr_json, _, status = Open3.capture3('gh', 'pr', 'view', '--json', 'state,isDraft,autoMergeRequest,statusCheckRollup,number')
  return nil if pr_json.empty? || !status.success?

  pr = JSON.parse(pr_json)
  checks = pr['statusCheckRollup'] || []
  ci_failing = checks.any? { |c| c['conclusion'] == 'FAILURE' }

  state = case pr['state']
  when 'MERGED'
    :merged
  when 'OPEN'
    if pr['isDraft']
      :draft
    elsif pr['autoMergeRequest']
      :automerge
    else
      :open
    end
  end

  # Get unresolved comment count via GraphQL
  unresolved = get_unresolved_comment_count(pr['number'])

  { state: state, unresolved_comments: unresolved, ci_failing: ci_failing }
rescue
  nil
end

# Count unresolved review threads using GraphQL
def get_unresolved_comment_count(pr_number)
  validate_positive_integer!(pr_number)

  repo_json, _, status = Open3.capture3('gh', 'repo', 'view', '--json', 'nameWithOwner', '-q', '.nameWithOwner')
  return 0 unless status.success?

  repo_name = repo_json.strip
  return 0 if repo_name.empty?

  validate_repo_name!(repo_name)
  owner, repo = repo_name.split('/')
  query = 'query($owner:String!,$repo:String!,$pr:Int!){repository(owner:$owner,name:$repo){pullRequest(number:$pr){reviewThreads(first:100){nodes{isResolved}}}}}'

  result_json, _, status = Open3.capture3(
    'gh', 'api', 'graphql',
    '-F', "owner=#{owner}",
    '-F', "repo=#{repo}",
    '-F', "pr=#{pr_number}",
    '-f', "query=#{query}"
  )
  return 0 unless status.success?

  result = JSON.parse(result_json)
  threads = result.dig('data', 'repository', 'pullRequest', 'reviewThreads', 'nodes') || []
  threads.count { |t| t['isResolved'] == false }
rescue ArgumentError
  raise
rescue StandardError
  0
end

pr_info = git_branch.empty? ? nil : get_pr_state
pr_state = pr_info&.dig(:state)
pr_unresolved = pr_info&.dig(:unresolved_comments) || 0
pr_ci_failing = pr_info&.dig(:ci_failing)

# Build status line matching your prompt style
# Reset color at the start for a clean baseline
status = "\033[0m"

# Model name with cost
if cost && cost != 0
  # Round to whole dollars
  cost_rounded = cost.round
  model_display = "#{model_display} \033[32m$#{cost_rounded}\033[0m"
end
status += "\033[36m#{model_display}\033[0m"

# Relative path
status += " #{relative_dir}"

# Yellow git branch in parens (like your prompt)
status += "\033[33m(#{git_branch})\033[0m" unless git_branch.empty?

# PR state indicator (GitHub colors)
comment_suffix = pr_unresolved > 0 ? " \033[33mðŸ—¨ #{pr_unresolved}\033[0m" : ""
ci_suffix = pr_ci_failing ? " \033[31mâœ—ci\033[0m" : ""
case pr_state
when :draft
  status += " \033[90mdraft\033[0m#{comment_suffix}#{ci_suffix}"
when :open
  status += " \033[32mopen\033[0m#{comment_suffix}#{ci_suffix}"
when :automerge
  status += " \033[32mautomerge\033[0m#{comment_suffix}#{ci_suffix}"
when :merged
  status += " \033[35mmerged\033[0m"
else
  # Only show dotted circle if not on a default branch
  status += " \033[90mâ—Œ\033[0m" if !git_branch.empty? && !%w[main master].include?(git_branch)
end

# AI emoji separator - options: ðŸ¤– âœ¨ ðŸ§  âš¡ ðŸ”®
status += ' ðŸ¤–'

# Add context info if available
# if context_input && context_output && context_size
#   # Format as "5% 10k/200k" style (percent used, consumed/total)
#   used = context_input + context_output
#   used_pct = (used.to_f / context_size * 100).round
#   used_k = (used / 1000.0).round
#   size_k = (context_size / 1000.0).round
#   status += " \033[35m#{used_pct}% #{used_k}k/#{size_k}k\033[0m"
# end

puts status
