#!/usr/bin/osascript -l JavaScript
// JavaScript for Automation script to toggle Voice Memos recording

// Handle --install flag
function run(argv) {
  if (argv.length > 0 && argv[0] === '--install') {
    const instructions = `## Hammerspoon Setup for Voice Memo Hotkey

### 1. Install Hammerspoon

\`\`\`bash
brew install hammerspoon --cask
\`\`\`

### 2. Add to ~/.hammerspoon/init.lua

\`\`\`lua
-- ============================================
-- Voice Memo Hotkey (Ctrl+\\\`)
-- Toggles Voice Memos recording
-- ============================================

local function toggleVoiceMemo()
  local voiceMemoPath = os.getenv("HOME") .. "/dropbox/dev/dotfiles/bin/voice-memo"
  hs.task.new(voiceMemoPath, function(exitCode, stdOut, stdErr)
    if exitCode == 0 then
      print("[Voice Memo] " .. stdOut)
      hs.notify.new({title="Voice Memo", informativeText=stdOut}):send()
    else
      print("[Voice Memo] Error: " .. stdErr)
      hs.notify.new({title="Voice Memo", informativeText="Error: " .. stdErr}):send()
    end
  end):start()
end

-- Bind Ctrl+\\\` to toggle voice memo
hs.hotkey.bind({"ctrl"}, "\\\`", toggleVoiceMemo)

print("✓ Voice Memo hotkey (Ctrl+\\\`) loaded")
\`\`\`

### 3. Reload Hammerspoon

Click Hammerspoon menu bar icon → "Reload Config"

### 4. Usage

- Press **Ctrl+\\\`** anywhere to start/stop Voice Memos recording
- First press: Opens Voice Memos and starts recording
- Second press: Stops and saves the recording
- You'll get a macOS notification confirming the action
`
    console.log(instructions)
    return
  }

  // Continue with normal voice memo toggle logic
  return toggleVoiceMemo()
}

function toggleVoiceMemo() {
  const voiceMemos = Application('Voice Memos')
  const systemEvents = Application('System Events')

  // Debug logging helper
  ObjC.import('stdlib')
  let DEBUG = false
  try {
    const debugEnv = $.getenv('DEBUG')
    if (debugEnv) {
      DEBUG = ObjC.unwrap(debugEnv) === '1'
    }
  } catch (e) {
    // DEBUG env var not set
  }
  function debug(msg) {
    if (DEBUG) console.log(msg)
  }

  // Function to wait for a condition with polling
  function waitForCondition(checkFunction, timeout = 5000) {
    const startTime = Date.now()
    while (Date.now() - startTime < timeout) {
      if (checkFunction()) {
        return true
      }
      delay(0.1) // 100ms
    }
    return false
  }

  // Get file URL from clipboard and return POSIX path
  function copyFileUrlFromClipboard() {
    ObjC.import('AppKit')
    ObjC.import('Foundation')

    const pasteboard = $.NSPasteboard.generalPasteboard
    const fileURLString = pasteboard.stringForType($.NSPasteboardTypeFileURL)

    if (fileURLString.js) {
      const url = $.NSURL.URLWithString(fileURLString)
      return ObjC.unwrap(url.path)
    }
    return null
  }

  // Get Downloads directory path
  function getDownloadsDir() {
    ObjC.import('Foundation')
    const homeDir = ObjC.unwrap($.NSHomeDirectory())
    return homeDir + '/Downloads'
  }

  // Get first static text value from Voice Memos toolbar
  // Returns the text value or defaultValue if not found
  function firstToolbarTextValue(systemEvents, defaultValue = 'Recording') {
    try {
      const vmWindow = systemEvents.processes['Voice Memos'].windows[0]
      const toolbar = vmWindow.toolbars[0]
      const toolbarElements = toolbar.uiElements()

      // Find the first static text element
      for (let i = 0; i < toolbarElements.length; i++) {
        if (toolbarElements[i].role() === 'AXStaticText') {
          return toolbarElements[i].value()
        }
      }
    } catch (e) {
      debug('Could not get toolbar text: ' + e)
    }
    return defaultValue
  }

  // Copy file to destination with deduplication (adds number suffix if file exists)
  // Returns: {success: boolean, destPath: string, error: string}
  function copyFileSafe(sourcePath, destDir, fileName) {
    ObjC.import('Foundation')

    const fileExt = fileName.includes('.')
      ? fileName.substring(fileName.lastIndexOf('.'))
      : '.m4a'
    const baseName = fileName.includes('.')
      ? fileName.substring(0, fileName.lastIndexOf('.'))
      : fileName

    let destPath = destDir + '/' + fileName
    if (!fileName.includes('.')) {
      destPath = destPath + '.m4a'
    }

    // Check for duplicates and add number suffix if needed
    const fileManager = $.NSFileManager.defaultManager
    let counter = 1
    while (fileManager.fileExistsAtPath(destPath)) {
      destPath = destDir + '/' + baseName + ' (' + counter + ')' + fileExt
      counter++
    }

    // Copy the file
    const sourceURL = $.NSURL.fileURLWithPath(sourcePath)
    const destURL = $.NSURL.fileURLWithPath(destPath)
    const errorPtr = Ref()

    const success = fileManager.copyItemAtURLToURLError(
      sourceURL,
      destURL,
      errorPtr
    )

    if (success) {
      return {success: true, destPath: destPath, error: null}
    } else {
      const error = ObjC.unwrap(errorPtr[0])
      const errorDesc = error ? error.localizedDescription.js : 'Unknown error'
      return {success: false, destPath: null, error: errorDesc}
    }
  }

  debug('Checking if Voice Memos is running...')
  const isRunning = voiceMemos.running()
  debug('Voice Memos running: ' + isRunning)

  // Activate Voice Memos if not running
  if (!isRunning) {
    debug('Starting Voice Memos...')
    voiceMemos.activate()

    debug('Waiting for Voice Memos to run...')
    const didRun = waitForCondition(() => voiceMemos.running())
    debug('Voice Memos running after wait: ' + didRun)
  } else {
    debug('Voice Memos already running, activating...')
    voiceMemos.activate()
  }

  debug('Waiting for Voice Memos to be frontmost...')
  const isFront = waitForCondition(() => voiceMemos.frontmost())
  debug('Voice Memos frontmost after wait: ' + isFront)

  debug('Accessing File menu...')
  const fileMenu =
    systemEvents.processes['Voice Memos'].menuBars[0].menuBarItems['File']
      .menus['File']
  debug('File menu accessed')

  // Check if currently recording by checking if "Done Editing" is enabled
  debug('Checking if currently recording...')
  const doneMenuItem = fileMenu.menuItems['Done Editing']
  const isRecording = doneMenuItem.enabled()
  debug('Currently recording: ' + isRecording)

  if (isRecording) {
    // Get recording name from toolbar before stopping
    debug('Getting recording name from toolbar...')
    const recordingName = firstToolbarTextValue(systemEvents)
    debug('Recording name: ' + recordingName)

    // Stop the recording
    debug('Stopping recording...')
    debug('Clicking Done Editing...')
    doneMenuItem.click()
    debug('Click completed')

    // Wait for recording to finish saving (menu state changes)
    debug('Waiting for recording to be saved...')
    const isSaved = waitForCondition(() => !doneMenuItem.enabled(), 10000)
    debug('Recording saved: ' + isSaved)

    if (!isSaved) {
      return 'Stopped recording but timed out waiting for save'
    }

    // Automatically copy recording to Downloads
    debug('Copying recording to Downloads...')

    // Copy recording to clipboard with Cmd+C
    debug('Pressing Cmd+C...')
    systemEvents.keystroke('c', {using: 'command down'})
    delay(0.5)

    // Get file path from clipboard
    const sourcePath = copyFileUrlFromClipboard()

    if (sourcePath) {
      debug('Source path: ' + sourcePath)

      const downloadsDir = getDownloadsDir()
      debug('Destination dir: ' + downloadsDir)

      const result = copyFileSafe(sourcePath, downloadsDir, recordingName)

      if (result.success) {
        const fileName = result.destPath.substring(result.destPath.lastIndexOf('/') + 1)
        return 'Stopped recording and copied to ~/Downloads/' + fileName
      } else {
        return 'Stopped recording but copy failed: ' + result.error
      }
    } else {
      return 'Stopped recording but could not get file from clipboard'
    }
  } else {
    // Start new recording
    debug('Starting new recording...')
    debug('Accessing Start New Recording menu item...')
    const menuItem = fileMenu.menuItems['Start New Recording']
    debug('Menu item accessed, enabled: ' + menuItem.enabled())

    debug('Clicking Start New Recording...')
    menuItem.click()
    debug('Click completed')
    return 'Started new voice memo recording'
  }
}
